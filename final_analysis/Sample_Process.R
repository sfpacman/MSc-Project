
library(Matrix)
library(ggplot2)
library(Rtsne)
library(svd)
library(dplyr)
library(scran)



### Functions are adpoted from https://github.com/10XGenomics/single-cell-3prime-paper for comparison

.get_variable_gene<-function(m) {
  
  df<-data.frame(mean=colMeans(m),cv=apply(m,2,sd)/colMeans(m),var=apply(m,2,var))
  df$dispersion<-with(df,var/mean)
  df$mean_bin<-with(df,cut(mean,breaks=c(-Inf,quantile(mean,seq(0.1,1,0.05)),Inf)))
  ## modtified if not enough unquie breaking points- add unique functions on quantile on cut 
  ## uncomment df$mean_bin 
  #df$mean_bin<-with(df,cut(mean,breaks=c(-Inf,unique(quantile(mean,seq(0.1,1,0.05))),Inf)))
  var_by_bin<-ddply(df,"mean_bin",function(x) {
    data.frame(bin_median=median(x$dispersion),
               bin_mad=mad(x$dispersion))
  })
  df$bin_disp_median<-var_by_bin$bin_median[match(df$mean_bin,var_by_bin$mean_bin)]
  df$bin_disp_mad<-var_by_bin$bin_mad[match(df$mean_bin,var_by_bin$mean_bin)]
  df$dispersion_norm<-with(df,abs(dispersion-bin_disp_median)/bin_disp_mad)
  df
}

.compare_by_cor<-function(m_filt,use_gene_ids,dmap_data) {
  
  sig_genes <- intersect(use_gene_ids, rownames(dmap_data))
  m_forsig <- as.matrix(m_filt[,which(use_gene_ids %in% sig_genes)])
  sig_data_filt <- dmap_data[match(use_gene_ids[which(use_gene_ids %in% sig_genes)], rownames(dmap_data)),]
  
  z <- lapply(1:ncol(sig_data_filt), function(j) sapply(1:nrow(m_forsig), function(i) cor(m_forsig[i,], sig_data_filt[,j], method='spearman')))
  z <- do.call(cbind, z)
  colnames(z) <- colnames(sig_data_filt)
  z
}                                                        
.reassign_pbmc_11<-function(z) {
  unlist(lapply(1:nrow(z),function(i) {
    best<-which.max(z[i,])
    x<-z[i,]
    nextbest<-which.max(x[x!=max(x)])
    # if best is CD4+ T helper, and the next best is cd4+/cd25+, or cd4+/cd45ro+ or cd4+/cd45ra+/cd25-, use the next best assignment
    if (best==9 & (nextbest==3 || nextbest==4 || nextbest==6)) {
      best=nextbest
    }
    # if best is CD8+, and the next best is CD8+/CD45RA+, use next best assignment
    if (best==7 & nextbest==5) {
      best=5
    }
    best
  }))
} 
.normalize_by_umi <-function(x) {
  cs <- colSums(x)
  x_use_genes <- which(cs >= 1)
  x_filt<-x[,x_use_genes]
  rs<-rowSums(x_filt)
  rs_med<-median(rs)
  x_norm<-x_filt/(rs/rs_med)
  list(m=x_norm,use_genes=x_use_genes)
}

.do_propack <- function(x,n) {
  use_genes <- which(colSums(x) > 1)
  m <- x[,use_genes]
  bc_tot <- rowSums(m)
  median_tot <- median(bc_tot)
  m <- sweep(m, 1, median_tot/bc_tot, '*')
  m <- log(1+m)
  m <- sweep(m, 2, colMeans(m), '-')
  m <- sweep(m, 2, apply(m, 2, sd), '/')
  ppk<-propack.svd(as.matrix(m),neig=n)
  pca<-t(ppk$d*t(ppk$u))
  list(ppk=ppk,pca=pca, m=m,use_genes=use_genes)
}
#### Data Loading ####
### the Two data sets are generated by: 
### https://github.com/10XGenomics/single-cell-3prime-paper/blob/master/pbmc68k_analysis/main_process_pure_pbmc.R
### 11 downsampled referebce expression data sets:
### subsampled_purified_mats : from line 1 to 45
### PCA results of 11 expression data sets 
### all_pure_pca : from line 47 to 51 
pure_id<-c("CD34+","CD56+ NK","CD4+/CD45RA+/CD25- Naive T", "CD4+/CD25 T Reg","CD8+/CD45RA+ Naive Cytotoxic",
           "CD4+/CD45RO+ Memory","CD8+ Cytotoxic T","CD19+ B","CD4+ T Helper2","CD14+ Monocyte","Dendritic")
spm <- readRDS("subsampled_purified_mats.rds")
app  <-readRDS("all_pure_pca.rds")
### getting a sample of gene expressions of 250 cells from each 11 popuations.  
sample <- get_sample(spm,app,pure_id,size=250, get_sum_list = TRUE)

### UMI Normalization ###
m <-sample$exp 
l<-.normalize_by_umi(m)
m_n<-l$m
sample_analysis$X <- list(m_n= l$m, use_genes= l$use_genes)
### computesumfactor nomrmalization###
use_genes<- which(colMeans(m) > 0)
M <- m[,use_genes]
M <- t(as.matrix(M))
### selecting highly expressed genes for avoiding negative size factor
high.ab <- which(rowMeans(M) >1)
### using quickcluster to speed up the normalization 
clusters <- quickCluster(M, subset.row=high.ab)
nor_fac <- computeSumFactors(M,subset.row=high.ab,cluster=clusters)
M_n <- nor_fac*t(M)
sample_analysis$S <- list(m_n= M_n, use_genes= use_genes)

### Corelation- Only applied to UMI Normalization  ###
df<-.get_variable_gene(sample_analysis$X$m_n) 
disp_cut_off<-sort(df$dispersion_norm,decreasing=T)[1000]
df$used<-df$dispersion_norm >= disp_cut_off
m_n_1000<-sample_analysis$X$m_n[,head(order(-df$dispersion_norm),1000)]
use_genes_n<-order(-df$dispersion_norm)
use_genes_n_ens<-pbmc68k$all_data[[1]]$hg19$genes[l$use_genes][order(-df$dispersion_norm)]
z_1000_11<-.compare_by_cor(m_filt,use_genes_n_ens[1:1000],purified_ref_11)
# reassign IDs, as there're some overlaps in the purified pbmc populations
test<-.reassign_pbmc_11(z_1000_11)
cls_id<-factor(colnames(z_1000_11)[test])
sample_analysis$X$cls_id <-cls_id

### For analysis that uses PCA+k-means for 10X umi normalization ### 
pca_n_1000<-.do_propack(m_n_1000,50)
### k-mean clustering ### 
k_n_1000<-kmeans(pca_n_1000$pca,10,iter.max=150,algorithm="MacQueen")
sample_analysis$X$k <-k_n_1000 
### For analysis that uses PCA+k-means for computeSumFactors ### 
df<-.get_variable_gene(sample_analysis$S$m_n) 
disp_cut_off<-sort(df$dispersion_norm,decreasing=T)[1000]
df$used<-df$dispersion_norm >= disp_cut_off
m_n_1000<-sample_analysis$S$m_n[,head(order(-df$dispersion_norm),1000)]
pca_n_1000<-.do_propack(m_n_1000,50)
k_n_1000<-kmeans(pca_n_1000$pca,10,iter.max=150,algorithm="MacQueen")
sample_analysis$S$k <-k_n_1000
saveRDS(sample_analysis,"sample_analysis.rds")
